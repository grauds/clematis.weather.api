buildscript {
    repositories {
        mavenCentral()
        maven {
            url "https://plugins.gradle.org/m2/"
        }
        google()
    }
}

plugins {
    id "org.springframework.boot" version "2.7.18"
    id 'io.spring.dependency-management' version '1.1.0' // needed for resolving spring boot deps
    id 'java'
    id 'groovy'

    id "org.flywaydb.flyway" version "9.8.1"

    id 'com.github.spotbugs' version '4.7.3'
    id 'org.asciidoctor.jvm.convert' version '3.1.0'
    id 'jacoco'
    id 'checkstyle'
    id 'idea'

    id 'com.palantir.docker' version '0.35.0'
    id 'com.palantir.docker-run' version '0.35.0'
    id 'com.palantir.docker-compose' version '0.35.0'
}

group 'name.troshin.anton.clematis'
version '0.0.1-SNAPSHOT'

sourceCompatibility = '11'
targetCompatibility = '11'

configurations {
    implementation.exclude group: "org.slf4j", module: "slf4j-log4j12"
}

repositories {
    mavenCentral()
}

apply from: file("${project.rootDir}/dependencies.gradle")

dependencies {

    implementation project(path: ':parser')

    annotationProcessor 'org.springframework.boot:spring-boot-configuration-processor'

    // for groovy
    implementation "org.codehaus.groovy:groovy-all:3.0.13"
    implementation "org.spockframework:spock-core:2.2-groovy-3.0"
    implementation "org.apache.ivy:ivy:2.5.1"

    implementation "com.google.auto.service:auto-service:1.0"
    implementation "org.springframework.boot:spring-boot-starter-actuator"
    implementation "org.springframework.boot:spring-boot-starter-data-jpa"
    implementation "org.springframework.boot:spring-boot-starter-data-rest"
    implementation "org.springframework.boot:spring-boot-starter-web"

    implementation "org.glassfish.main.external:jmxremote_optional-repackaged:5.0"

    implementation "org.springdoc:springdoc-openapi-ui:1.6.14"
    implementation "org.springdoc:springdoc-openapi-hateoas:1.6.14"
    implementation "org.springdoc:springdoc-openapi-data-rest:1.6.14"

    implementation "org.flywaydb:flyway-core:9.15.0"
    implementation "org.flywaydb:flyway-mysql:9.15.0"
    implementation "mysql:mysql-connector-java:8.0.32"

    testCompileOnly "org.testcontainers:testcontainers:1.17.6"
    testCompileOnly "org.testcontainers:junit-jupiter:1.17.6"
    testCompileOnly "org.testcontainers:testcontainers-bom:1.17.6"
    testCompileOnly "org.testcontainers:mysql:1.17.6"
    testImplementation "org.testcontainers:mysql:1.17.6"
    testImplementation platform("org.testcontainers:testcontainers-bom:1.17.6")

    testImplementation 'io.rest-assured:rest-assured'

    testImplementation 'io.netty:netty-all:4.1.86.Final'
    testImplementation ('org.springframework.boot:spring-boot-starter-test:2.7.9') {
        exclude group: 'org.junit.vintage', module: 'junit-vintage-engine'
    }

    testImplementation 'org.springframework.restdocs:spring-restdocs-mockmvc'
}

// ------------ JaCoCo test coverage + ascii doctor as a post processor

ext {
    setProperty('snippetsDir', file("build/generated-snippets"))
}

test {
    outputs.dir snippetsDir
    useJUnitPlatform()
    testLogging.showStandardStreams = true
    finalizedBy jacocoTestReport
    jacoco {
        destinationFile = file("jacoco/jacocoTest.exec")
        classDumpDir = file("jacoco/classpathdumps")
    }
}

task codeCoverageReport(type: JacocoReport) {
    executionData fileTree(project.rootDir.absolutePath).include("**/build/jacoco/*.exec")

    allprojects.each {
        sourceSets it.sourceSets.main
    }

    reports {
        xml.enabled true
        xml.destination file("jacoco/report.xml")
        html.enabled true
        csv.enabled false
    }
}

// always run the tests before generating the report
codeCoverageReport.dependsOn {
    subprojects.test
}

jacocoTestReport {
    dependsOn test // tests are required to run before generating the report
    reports {
        xml.required = true
        csv.required = false
        html.outputLocation = file('jacoco/html')
        xml.outputLocation = file('jacoco/jacoco.xml')
    }
}

// Share sources folder with other projects for aggregated JaCoCo reports
configurations.create('transitiveSourcesElements') {
    visible = false
    canBeResolved = false
    canBeConsumed = true
    extendsFrom(configurations.implementation)
    attributes {
        attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
        attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
        attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'source-folders'))
    }
    sourceSets.main.java.srcDirs.forEach {
        outgoing.artifact(it)
    }
}

// Share the coverage data to be aggregated for the whole product
configurations.create('coverageDataElements') {
    visible = false
    canBeResolved = false
    canBeConsumed = true
    extendsFrom(configurations.implementation)
    attributes {
        attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage, Usage.JAVA_RUNTIME))
        attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category, Category.DOCUMENTATION))
        attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType, 'jacoco-coverage-data'))
    }
    // This will cause the test task to run if the coverage data is requested by the aggregation task
    outgoing.artifact(tasks.named("test").map { task ->
        task.extensions.getByType(JacocoTaskExtension).destinationFile
    })
}

// Make JaCoCo report generation part of the 'check' lifecycle phase
tasks.named("check") {
    dependsOn(codeCoverageReport)
}

asciidoctor {
    inputs.dir snippetsDir
    dependsOn test
}

// dependencies for the root web project and for the other subprojects
allprojects {

    apply plugin: 'java'

    apply plugin: 'jacoco'
    apply plugin: 'checkstyle'
    apply plugin: 'idea'
    apply plugin: 'eclipse'

    apply from: file("${project.rootDir}/dependencies.gradle")

    // ------------ Spotbugs configuration  ---------
    spotbugsMain {
        reports {
            xml {
                enabled = false
            }
            html {
                enabled = true
                destination = file("$buildDir/reports/spotbugs/main/spotbugs.html")
            }
        }
    }

    spotbugsTest {
        reports {
            xml {
                enabled = false
            }
            html {
                enabled = true
                destination = file("$buildDir/reports/spotbugs/test/spotbugs.html")
            }
        }
    }

    // ------------ Checkstyle configuration  ---------
    checkstyle {
        configProperties.configFile = file("${project.rootDir}/config/checkstyle/checkstyle.xml")
        configProperties.checkstyleSuppressionFile = file("${project.rootDir}/config/checkstyle/suppressions.xml")
    }

    task checkstyleReport {
        doLast {
            if (file("${buildDir}/reports/checkstyle/${project.ext.checkType}.xml").exists()) {
                ant.xslt(in: "${buildDir}/reports/checkstyle/${project.ext.checkType}.xml",
                        style: "${project.rootDir}/config/checkstyle/checkstyle.xsl",
                        out: "${buildDir}/reports/checkstyle/checkstyle_${project.ext.checkType}.html")
            }
        }
    }

    tasks.withType(Checkstyle) {
        exclude '**/*Test*'
    }
}

docker {
    name = "atroshin/${project.name}:${version}"
    dockerfile = file('Dockerfile')
    copySpec.from("${buildDir}").into("build")
    pull true
    noCache true
}

dockerCompose {
    dockerComposeFile file("${project.rootDir}/docker/docker-compose.yml")
}

dockerRun {
    name 'clematis.weather.api'
    image "atroshin/${project.name}:${version}"
    ports '18087:8080'
}

springBoot {
    buildInfo {
        properties {
            artifact = 'clematis-weather-api'
            version = version
            group = 'org.clematis.weather'
            name = 'Clematis Weather API'
        }
    }
}

